### This file was generated by Nexus Schema
### Do not make changes to this file directly

type AmountRange {
  amount: BN
  length: BN
}

type Artwork {
  creators: [ArtworkCreator]
  edition: BN
  maxSupply: BN
  mint: PublicKey
  pubkey: PublicKey!
  sellerFeeBasisPoints: Int!
  supply: BN
  title: String!
  type: Int!
  uri: String!
}

type ArtworkCreator {
  address: PublicKey!
  share: Int!
  verified: Boolean!
}

input ArtworksInput {
  artId: String
  creatorId: String
  onlyVerified: Boolean
  ownerId: String
  storeId: String!
}

type Auction {
  """
  Gap time is the amount of time in slots after the previous bid at which the auction ends.
  """
  auctionGap: BN

  """
  Pubkey of the authority with permission to modify this auction.
  """
  authority: PublicKey!

  """
  Used for precalculation on the front end, not a backend key
  """
  bidRedemptionKey: PublicKey

  """
  Auction Bids, each user may have one bid open at a time.
  """
  bidState: BidState!

  """
  End time is the cut-off point that the auction is forced to end by.
  """
  endAuctionAt: BN

  """
  Slot time the auction was officially ended by.
  """
  endedAt: BN

  """
  The time the last bid was placed, used to keep track of auction timing.
  """
  lastBid: BN
  manager: AuctionManager!
  numWinners: BN!

  """
  Minimum price for any bid to meet.
  """
  priceFloor: PriceFloor!
  pubkey: PublicKey!

  """
  The state the auction is in, whether it has started or ended.
  """
  state: AuctionState!

  """
  Token mint for the SPL token being used to bid
  """
  tokenMint: PublicKey!
  viewState: AuctionViewState!
}

enum AuctionInputState {
  all
  ended
  live
  resale
}

type AuctionManager {
  acceptPayment: PublicKey!
  auction: PublicKey!
  authority: PublicKey!
  store: PublicKey!
  vault: PublicKey!
}

type AuctionManagerStateV1 {
  status: Int
  winningConfigItemsValidated: Int
}

type AuctionManagerStateV2 {
  bidsPushedToAcceptPayment: BN
  hasParticipation: Boolean
  safetyConfigItemsValidated: BN
  status: Int
}

type AuctionManagerV1 {
  acceptPayment: PublicKey
  auction: PublicKey
  authority: PublicKey
  key: Int
  state: AuctionManagerStateV1
  store: PublicKey
  vault: PublicKey
}

type AuctionManagerV2 {
  acceptPayment: PublicKey
  auction: PublicKey
  authority: PublicKey
  key: Int
  state: AuctionManagerStateV2
  store: PublicKey
  vault: PublicKey
}

enum AuctionState {
  Created
  Ended
  Started
}

enum AuctionViewState {
  BuyNow
  Defective
  Ended
  Live
  Upcoming
}

input AuctionsInput {
  participantId: String
  state: AuctionInputState
  storeId: String
}

"""
GraphQL representation of BigNumber
"""
scalar BN

type Bid {
  amount: BN!
  key: PublicKey!
}

type BidRedemptionTicket {
  key: Int
}

type BidState {
  bids: [Bid]!
  max: BN!
  type: BidStateType!
}

enum BidStateType {
  EnglishAuction
  OpenEdition
}

type Creator {
  activated: Boolean!
  address: PublicKey!
  key: Int!
  pubkey: PublicKey!
}

type Edition {
  """
  Starting at 0 for master record, this is incremented for each edition minted
  """
  edition: BN
  key: MetadataKey

  """
  Points at MasterEdition struct
  """
  parent: PublicKey
}

union MasterEdition = MasterEditionV1 | MasterEditionV2

type MasterEditionV1 {
  key: MetadataKey
  maxSupply: BN
  oneTimePrintingAuthorizationMint: PublicKey
  printingMint: PublicKey
  supply: BN
}

type MasterEditionV2 {
  key: MetadataKey
  maxSupply: BN
  supply: BN
}

enum MetadataKey {
  EditionMarker
  EditionV1
  MasterEditionV1
  MasterEditionV2
  MetadataV1
  Uninitialized
}

enum NonWinningConstraint {
  GivenForBidPrice
  GivenForFixedPrice
  NoParticipationPrize
}

type ParticipationConfig {
  fixedPrice: BN
  nonWinningConstraint: NonWinningConstraint
  safetyDepositBoxIndex: Int
  winnerConstraint: WinningConstraint
}

type ParticipationStateV2 {
  collectedToAcceptPayment: BN
}

type PayoutTicket {
  amountPaid: BN
  key: Int
  recipient: PublicKey
}

type PriceFloor {
  minPrice: BN
  type: PriceFloorType!
}

enum PriceFloorType {
  BlindedPrice
  Minimum
  None
}

type PrizeTrackingTicket {
  expectedRedemptions: BN
  key: Int
  metadata: PublicKey
  redemptions: BN
  supplySnapshot: BN
}

scalar PublicKey

type Query {
  artwork(artId: String!, storeId: String): Artwork
  artworks(filter: ArtworksInput!): [Artwork!]
  artworksCount: Int
  auctionsCount: Int
  creator(creatorId: String!, storeId: String!): Creator
  creators(storeId: String!): [Creator!]
  creatorsCount: Int
  store(storeId: String!): Store
  stores: [Store!]
  storesCount: Int
}

type SafetyDepositBox {
  """
  Each token type in a vault has it's own box that contains it's mint and a look-back
  """
  key: VaultKey!
  order: Int! @deprecated(reason: "The order in the array of registries")

  """
  Account that stores the tokens under management
  """
  store: PublicKey!

  """
  This particular token's mint
  """
  tokenMint: PublicKey!
  vault: PublicKey! @deprecated(reason: "VaultKey pointing to the parent vault")
}

type SafetyDepositConfig {
  amountRanges: [AmountRange]
  amountType: TupleNumericType
  auctionManager: PublicKey
  key: Int
  lengthType: TupleNumericType
  order: BN
  participationConfig: ParticipationConfig
  participationState: ParticipationStateV2
  winningConfigType: WinningConfigType
}

type Store {
  auctionProgram: PublicKey!
  key: Int!
  pubkey: PublicKey!
  public: Boolean!
  tokenMetadataProgram: PublicKey!
  tokenProgram: PublicKey!
  tokenVaultProgram: PublicKey!
}

type Subscription {
  auction(id: String!): Auction
  auctions: Auction
  creator(id: String!): Creator
  creators: Creator
  store(id: String!): Store
  stores: Store
  ticks: Boolean
}

enum TupleNumericType {
  U8
  U16
  U32
  U64
}

type Vault {
  """
  Can authority mint more shares from fraction_mint after activation
  """
  allowFurtherShareCreation: Boolean

  """
  Authority who can make changes to the vault
  """
  authority: PublicKey

  """
  Mint that produces the fractional shares
  """
  fractionMint: PublicKey

  """
  treasury where fractional shares are held for redemption by authority
  """
  fractionTreasury: PublicKey
  key: VaultKey

  """
  Once combination happens, we copy price per share to vault so that if something nefarious happens
  to external price account, like price change, we still have the math 'saved' for use in our calcs
  """
  lockedPricePerShare: BN

  """
  Must point at an ExternalPriceAccount, which gives permission and price for buyout.
  """
  pricingLookupAddress: PublicKey

  """
  treasury where monies are held for fractional share holders to redeem(burn) shares once buyout is made
  """
  redeemTreasury: PublicKey
  state: VaultState
  tokenProgram: PublicKey @deprecated(reason: "Store token program used")

  """
  In inactive state, we use this to set the order key on Safety Deposit Boxes being added and
  then we increment it and save so the next safety deposit box gets the next number.
  In the Combined state during token redemption by authority, we use it as a decrementing counter each time
  The authority of the vault withdrawals a Safety Deposit contents to count down how many
  are left to be opened and closed down. Once this hits zero, and the fraction mint has zero shares,
  then we can deactivate the vault.
  """
  tokenTypeCount: Int
}

enum VaultKey {
  ExternalPriceAccountV1
  SafetyDepositBoxV1
  Uninitialized
  VaultV1
}

enum VaultState {
  Active
  Combined
  Deactivated
  Inactive
}

enum WinningConfigType {
  FullRightsTransfer
  Participation
  PrintingV1
  PrintingV2
  TokenOnlyTransfer
}

enum WinningConstraint {
  NoParticipationPrize
  ParticipationPrizeGiven
}
