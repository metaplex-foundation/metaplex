/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ErrorWithCode = Error & { code: number };
type MaybeErrorWithCode = ErrorWithCode | null | undefined;

const createErrorFromCodeLookup: Map<number, () => ErrorWithCode> = new Map();
const createErrorFromNameLookup: Map<string, () => ErrorWithCode> = new Map();

/**
 * InstructionUnpackError: 'Failed to unpack instruction data'
 *
 * @category Errors
 * @category generated
 */
export class InstructionUnpackErrorError extends Error {
  readonly code: number = 0x0;
  readonly name: string = 'InstructionUnpackError';
  constructor() {
    super('Failed to unpack instruction data');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InstructionUnpackErrorError);
    }
  }
}

createErrorFromCodeLookup.set(0x0, () => new InstructionUnpackErrorError());
createErrorFromNameLookup.set('InstructionUnpackError', () => new InstructionUnpackErrorError());

/**
 * InstructionPackError: 'Failed to pack instruction data'
 *
 * @category Errors
 * @category generated
 */
export class InstructionPackErrorError extends Error {
  readonly code: number = 0x1;
  readonly name: string = 'InstructionPackError';
  constructor() {
    super('Failed to pack instruction data');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InstructionPackErrorError);
    }
  }
}

createErrorFromCodeLookup.set(0x1, () => new InstructionPackErrorError());
createErrorFromNameLookup.set('InstructionPackError', () => new InstructionPackErrorError());

/**
 * NotRentExempt: 'Lamport balance below rent-exempt threshold'
 *
 * @category Errors
 * @category generated
 */
export class NotRentExemptError extends Error {
  readonly code: number = 0x2;
  readonly name: string = 'NotRentExempt';
  constructor() {
    super('Lamport balance below rent-exempt threshold');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotRentExemptError);
    }
  }
}

createErrorFromCodeLookup.set(0x2, () => new NotRentExemptError());
createErrorFromNameLookup.set('NotRentExempt', () => new NotRentExemptError());

/**
 * AlreadyInitialized: 'Already initialized'
 *
 * @category Errors
 * @category generated
 */
export class AlreadyInitializedError extends Error {
  readonly code: number = 0x3;
  readonly name: string = 'AlreadyInitialized';
  constructor() {
    super('Already initialized');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AlreadyInitializedError);
    }
  }
}

createErrorFromCodeLookup.set(0x3, () => new AlreadyInitializedError());
createErrorFromNameLookup.set('AlreadyInitialized', () => new AlreadyInitializedError());

/**
 * Uninitialized: 'Uninitialized'
 *
 * @category Errors
 * @category generated
 */
export class UninitializedError extends Error {
  readonly code: number = 0x4;
  readonly name: string = 'Uninitialized';
  constructor() {
    super('Uninitialized');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UninitializedError);
    }
  }
}

createErrorFromCodeLookup.set(0x4, () => new UninitializedError());
createErrorFromNameLookup.set('Uninitialized', () => new UninitializedError());

/**
 * InvalidMetadataKey: ' Metadata's key must match seed of ['metadata', program id, mint] provided'
 *
 * @category Errors
 * @category generated
 */
export class InvalidMetadataKeyError extends Error {
  readonly code: number = 0x5;
  readonly name: string = 'InvalidMetadataKey';
  constructor() {
    super(" Metadata's key must match seed of ['metadata', program id, mint] provided");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidMetadataKeyError);
    }
  }
}

createErrorFromCodeLookup.set(0x5, () => new InvalidMetadataKeyError());
createErrorFromNameLookup.set('InvalidMetadataKey', () => new InvalidMetadataKeyError());

/**
 * InvalidEditionKey: 'Edition's key must match seed of ['metadata', program id, name, 'edition'] provided'
 *
 * @category Errors
 * @category generated
 */
export class InvalidEditionKeyError extends Error {
  readonly code: number = 0x6;
  readonly name: string = 'InvalidEditionKey';
  constructor() {
    super("Edition's key must match seed of ['metadata', program id, name, 'edition'] provided");
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidEditionKeyError);
    }
  }
}

createErrorFromCodeLookup.set(0x6, () => new InvalidEditionKeyError());
createErrorFromNameLookup.set('InvalidEditionKey', () => new InvalidEditionKeyError());

/**
 * UpdateAuthorityIncorrect: 'Update Authority given does not match'
 *
 * @category Errors
 * @category generated
 */
export class UpdateAuthorityIncorrectError extends Error {
  readonly code: number = 0x7;
  readonly name: string = 'UpdateAuthorityIncorrect';
  constructor() {
    super('Update Authority given does not match');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UpdateAuthorityIncorrectError);
    }
  }
}

createErrorFromCodeLookup.set(0x7, () => new UpdateAuthorityIncorrectError());
createErrorFromNameLookup.set(
  'UpdateAuthorityIncorrect',
  () => new UpdateAuthorityIncorrectError(),
);

/**
 * UpdateAuthorityIsNotSigner: 'Update Authority needs to be signer to update metadata'
 *
 * @category Errors
 * @category generated
 */
export class UpdateAuthorityIsNotSignerError extends Error {
  readonly code: number = 0x8;
  readonly name: string = 'UpdateAuthorityIsNotSigner';
  constructor() {
    super('Update Authority needs to be signer to update metadata');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UpdateAuthorityIsNotSignerError);
    }
  }
}

createErrorFromCodeLookup.set(0x8, () => new UpdateAuthorityIsNotSignerError());
createErrorFromNameLookup.set(
  'UpdateAuthorityIsNotSigner',
  () => new UpdateAuthorityIsNotSignerError(),
);

/**
 * NotMintAuthority: 'You must be the mint authority and signer on this transaction'
 *
 * @category Errors
 * @category generated
 */
export class NotMintAuthorityError extends Error {
  readonly code: number = 0x9;
  readonly name: string = 'NotMintAuthority';
  constructor() {
    super('You must be the mint authority and signer on this transaction');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotMintAuthorityError);
    }
  }
}

createErrorFromCodeLookup.set(0x9, () => new NotMintAuthorityError());
createErrorFromNameLookup.set('NotMintAuthority', () => new NotMintAuthorityError());

/**
 * InvalidMintAuthority: 'Mint authority provided does not match the authority on the mint'
 *
 * @category Errors
 * @category generated
 */
export class InvalidMintAuthorityError extends Error {
  readonly code: number = 0xa;
  readonly name: string = 'InvalidMintAuthority';
  constructor() {
    super('Mint authority provided does not match the authority on the mint');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidMintAuthorityError);
    }
  }
}

createErrorFromCodeLookup.set(0xa, () => new InvalidMintAuthorityError());
createErrorFromNameLookup.set('InvalidMintAuthority', () => new InvalidMintAuthorityError());

/**
 * NameTooLong: 'Name too long'
 *
 * @category Errors
 * @category generated
 */
export class NameTooLongError extends Error {
  readonly code: number = 0xb;
  readonly name: string = 'NameTooLong';
  constructor() {
    super('Name too long');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NameTooLongError);
    }
  }
}

createErrorFromCodeLookup.set(0xb, () => new NameTooLongError());
createErrorFromNameLookup.set('NameTooLong', () => new NameTooLongError());

/**
 * SymbolTooLong: 'Symbol too long'
 *
 * @category Errors
 * @category generated
 */
export class SymbolTooLongError extends Error {
  readonly code: number = 0xc;
  readonly name: string = 'SymbolTooLong';
  constructor() {
    super('Symbol too long');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, SymbolTooLongError);
    }
  }
}

createErrorFromCodeLookup.set(0xc, () => new SymbolTooLongError());
createErrorFromNameLookup.set('SymbolTooLong', () => new SymbolTooLongError());

/**
 * UriTooLong: 'URI too long'
 *
 * @category Errors
 * @category generated
 */
export class UriTooLongError extends Error {
  readonly code: number = 0xd;
  readonly name: string = 'UriTooLong';
  constructor() {
    super('URI too long');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UriTooLongError);
    }
  }
}

createErrorFromCodeLookup.set(0xd, () => new UriTooLongError());
createErrorFromNameLookup.set('UriTooLong', () => new UriTooLongError());

/**
 * UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner: 'Update authority must be equivalent to the metadata's authority and also signer of this transaction'
 *
 * @category Errors
 * @category generated
 */
export class UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError extends Error {
  readonly code: number = 0xe;
  readonly name: string = 'UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner';
  constructor() {
    super(
      "Update authority must be equivalent to the metadata's authority and also signer of this transaction",
    );
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError);
    }
  }
}

createErrorFromCodeLookup.set(
  0xe,
  () => new UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError(),
);
createErrorFromNameLookup.set(
  'UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner',
  () => new UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError(),
);

/**
 * MintMismatch: 'Mint given does not match mint on Metadata'
 *
 * @category Errors
 * @category generated
 */
export class MintMismatchError extends Error {
  readonly code: number = 0xf;
  readonly name: string = 'MintMismatch';
  constructor() {
    super('Mint given does not match mint on Metadata');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MintMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0xf, () => new MintMismatchError());
createErrorFromNameLookup.set('MintMismatch', () => new MintMismatchError());

/**
 * EditionsMustHaveExactlyOneToken: 'Editions must have exactly one token'
 *
 * @category Errors
 * @category generated
 */
export class EditionsMustHaveExactlyOneTokenError extends Error {
  readonly code: number = 0x10;
  readonly name: string = 'EditionsMustHaveExactlyOneToken';
  constructor() {
    super('Editions must have exactly one token');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, EditionsMustHaveExactlyOneTokenError);
    }
  }
}

createErrorFromCodeLookup.set(0x10, () => new EditionsMustHaveExactlyOneTokenError());
createErrorFromNameLookup.set(
  'EditionsMustHaveExactlyOneToken',
  () => new EditionsMustHaveExactlyOneTokenError(),
);

/**
 * MaxEditionsMintedAlready: 'Maximum editions printed already'
 *
 * @category Errors
 * @category generated
 */
export class MaxEditionsMintedAlreadyError extends Error {
  readonly code: number = 0x11;
  readonly name: string = 'MaxEditionsMintedAlready';
  constructor() {
    super('Maximum editions printed already');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MaxEditionsMintedAlreadyError);
    }
  }
}

createErrorFromCodeLookup.set(0x11, () => new MaxEditionsMintedAlreadyError());
createErrorFromNameLookup.set(
  'MaxEditionsMintedAlready',
  () => new MaxEditionsMintedAlreadyError(),
);

/**
 * TokenMintToFailed: 'Token mint to failed'
 *
 * @category Errors
 * @category generated
 */
export class TokenMintToFailedError extends Error {
  readonly code: number = 0x12;
  readonly name: string = 'TokenMintToFailed';
  constructor() {
    super('Token mint to failed');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TokenMintToFailedError);
    }
  }
}

createErrorFromCodeLookup.set(0x12, () => new TokenMintToFailedError());
createErrorFromNameLookup.set('TokenMintToFailed', () => new TokenMintToFailedError());

/**
 * MasterRecordMismatch: 'The master edition record passed must match the master record on the edition given'
 *
 * @category Errors
 * @category generated
 */
export class MasterRecordMismatchError extends Error {
  readonly code: number = 0x13;
  readonly name: string = 'MasterRecordMismatch';
  constructor() {
    super('The master edition record passed must match the master record on the edition given');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MasterRecordMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x13, () => new MasterRecordMismatchError());
createErrorFromNameLookup.set('MasterRecordMismatch', () => new MasterRecordMismatchError());

/**
 * DestinationMintMismatch: 'The destination account does not have the right mint'
 *
 * @category Errors
 * @category generated
 */
export class DestinationMintMismatchError extends Error {
  readonly code: number = 0x14;
  readonly name: string = 'DestinationMintMismatch';
  constructor() {
    super('The destination account does not have the right mint');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DestinationMintMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x14, () => new DestinationMintMismatchError());
createErrorFromNameLookup.set('DestinationMintMismatch', () => new DestinationMintMismatchError());

/**
 * EditionAlreadyMinted: 'An edition can only mint one of its kind!'
 *
 * @category Errors
 * @category generated
 */
export class EditionAlreadyMintedError extends Error {
  readonly code: number = 0x15;
  readonly name: string = 'EditionAlreadyMinted';
  constructor() {
    super('An edition can only mint one of its kind!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, EditionAlreadyMintedError);
    }
  }
}

createErrorFromCodeLookup.set(0x15, () => new EditionAlreadyMintedError());
createErrorFromNameLookup.set('EditionAlreadyMinted', () => new EditionAlreadyMintedError());

/**
 * PrintingMintDecimalsShouldBeZero: 'Printing mint decimals should be zero'
 *
 * @category Errors
 * @category generated
 */
export class PrintingMintDecimalsShouldBeZeroError extends Error {
  readonly code: number = 0x16;
  readonly name: string = 'PrintingMintDecimalsShouldBeZero';
  constructor() {
    super('Printing mint decimals should be zero');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PrintingMintDecimalsShouldBeZeroError);
    }
  }
}

createErrorFromCodeLookup.set(0x16, () => new PrintingMintDecimalsShouldBeZeroError());
createErrorFromNameLookup.set(
  'PrintingMintDecimalsShouldBeZero',
  () => new PrintingMintDecimalsShouldBeZeroError(),
);

/**
 * OneTimePrintingAuthorizationMintDecimalsShouldBeZero: 'OneTimePrintingAuthorization mint decimals should be zero'
 *
 * @category Errors
 * @category generated
 */
export class OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError extends Error {
  readonly code: number = 0x17;
  readonly name: string = 'OneTimePrintingAuthorizationMintDecimalsShouldBeZero';
  constructor() {
    super('OneTimePrintingAuthorization mint decimals should be zero');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x17,
  () => new OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError(),
);
createErrorFromNameLookup.set(
  'OneTimePrintingAuthorizationMintDecimalsShouldBeZero',
  () => new OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError(),
);

/**
 * EditionMintDecimalsShouldBeZero: 'EditionMintDecimalsShouldBeZero'
 *
 * @category Errors
 * @category generated
 */
export class EditionMintDecimalsShouldBeZeroError extends Error {
  readonly code: number = 0x18;
  readonly name: string = 'EditionMintDecimalsShouldBeZero';
  constructor() {
    super('EditionMintDecimalsShouldBeZero');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, EditionMintDecimalsShouldBeZeroError);
    }
  }
}

createErrorFromCodeLookup.set(0x18, () => new EditionMintDecimalsShouldBeZeroError());
createErrorFromNameLookup.set(
  'EditionMintDecimalsShouldBeZero',
  () => new EditionMintDecimalsShouldBeZeroError(),
);

/**
 * TokenBurnFailed: 'Token burn failed'
 *
 * @category Errors
 * @category generated
 */
export class TokenBurnFailedError extends Error {
  readonly code: number = 0x19;
  readonly name: string = 'TokenBurnFailed';
  constructor() {
    super('Token burn failed');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TokenBurnFailedError);
    }
  }
}

createErrorFromCodeLookup.set(0x19, () => new TokenBurnFailedError());
createErrorFromNameLookup.set('TokenBurnFailed', () => new TokenBurnFailedError());

/**
 * TokenAccountOneTimeAuthMintMismatch: 'The One Time authorization mint does not match that on the token account!'
 *
 * @category Errors
 * @category generated
 */
export class TokenAccountOneTimeAuthMintMismatchError extends Error {
  readonly code: number = 0x1a;
  readonly name: string = 'TokenAccountOneTimeAuthMintMismatch';
  constructor() {
    super('The One Time authorization mint does not match that on the token account!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TokenAccountOneTimeAuthMintMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x1a, () => new TokenAccountOneTimeAuthMintMismatchError());
createErrorFromNameLookup.set(
  'TokenAccountOneTimeAuthMintMismatch',
  () => new TokenAccountOneTimeAuthMintMismatchError(),
);

/**
 * DerivedKeyInvalid: 'Derived key invalid'
 *
 * @category Errors
 * @category generated
 */
export class DerivedKeyInvalidError extends Error {
  readonly code: number = 0x1b;
  readonly name: string = 'DerivedKeyInvalid';
  constructor() {
    super('Derived key invalid');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DerivedKeyInvalidError);
    }
  }
}

createErrorFromCodeLookup.set(0x1b, () => new DerivedKeyInvalidError());
createErrorFromNameLookup.set('DerivedKeyInvalid', () => new DerivedKeyInvalidError());

/**
 * PrintingMintMismatch: 'The Printing mint does not match that on the master edition!'
 *
 * @category Errors
 * @category generated
 */
export class PrintingMintMismatchError extends Error {
  readonly code: number = 0x1c;
  readonly name: string = 'PrintingMintMismatch';
  constructor() {
    super('The Printing mint does not match that on the master edition!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PrintingMintMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x1c, () => new PrintingMintMismatchError());
createErrorFromNameLookup.set('PrintingMintMismatch', () => new PrintingMintMismatchError());

/**
 * OneTimePrintingAuthMintMismatch: 'The One Time Printing Auth mint does not match that on the master edition!'
 *
 * @category Errors
 * @category generated
 */
export class OneTimePrintingAuthMintMismatchError extends Error {
  readonly code: number = 0x1d;
  readonly name: string = 'OneTimePrintingAuthMintMismatch';
  constructor() {
    super('The One Time Printing Auth mint does not match that on the master edition!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, OneTimePrintingAuthMintMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x1d, () => new OneTimePrintingAuthMintMismatchError());
createErrorFromNameLookup.set(
  'OneTimePrintingAuthMintMismatch',
  () => new OneTimePrintingAuthMintMismatchError(),
);

/**
 * TokenAccountMintMismatch: 'The mint of the token account does not match the Printing mint!'
 *
 * @category Errors
 * @category generated
 */
export class TokenAccountMintMismatchError extends Error {
  readonly code: number = 0x1e;
  readonly name: string = 'TokenAccountMintMismatch';
  constructor() {
    super('The mint of the token account does not match the Printing mint!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TokenAccountMintMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x1e, () => new TokenAccountMintMismatchError());
createErrorFromNameLookup.set(
  'TokenAccountMintMismatch',
  () => new TokenAccountMintMismatchError(),
);

/**
 * TokenAccountMintMismatchV2: 'The mint of the token account does not match the master metadata mint!'
 *
 * @category Errors
 * @category generated
 */
export class TokenAccountMintMismatchV2Error extends Error {
  readonly code: number = 0x1f;
  readonly name: string = 'TokenAccountMintMismatchV2';
  constructor() {
    super('The mint of the token account does not match the master metadata mint!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TokenAccountMintMismatchV2Error);
    }
  }
}

createErrorFromCodeLookup.set(0x1f, () => new TokenAccountMintMismatchV2Error());
createErrorFromNameLookup.set(
  'TokenAccountMintMismatchV2',
  () => new TokenAccountMintMismatchV2Error(),
);

/**
 * NotEnoughTokens: 'Not enough tokens to mint a limited edition'
 *
 * @category Errors
 * @category generated
 */
export class NotEnoughTokensError extends Error {
  readonly code: number = 0x20;
  readonly name: string = 'NotEnoughTokens';
  constructor() {
    super('Not enough tokens to mint a limited edition');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotEnoughTokensError);
    }
  }
}

createErrorFromCodeLookup.set(0x20, () => new NotEnoughTokensError());
createErrorFromNameLookup.set('NotEnoughTokens', () => new NotEnoughTokensError());

/**
 * PrintingMintAuthorizationAccountMismatch: 'The mint on your authorization token holding account does not match your Printing mint!'
 *
 * @category Errors
 * @category generated
 */
export class PrintingMintAuthorizationAccountMismatchError extends Error {
  readonly code: number = 0x21;
  readonly name: string = 'PrintingMintAuthorizationAccountMismatch';
  constructor() {
    super(
      'The mint on your authorization token holding account does not match your Printing mint!',
    );
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PrintingMintAuthorizationAccountMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x21, () => new PrintingMintAuthorizationAccountMismatchError());
createErrorFromNameLookup.set(
  'PrintingMintAuthorizationAccountMismatch',
  () => new PrintingMintAuthorizationAccountMismatchError(),
);

/**
 * AuthorizationTokenAccountOwnerMismatch: 'The authorization token account has a different owner than the update authority for the master edition!'
 *
 * @category Errors
 * @category generated
 */
export class AuthorizationTokenAccountOwnerMismatchError extends Error {
  readonly code: number = 0x22;
  readonly name: string = 'AuthorizationTokenAccountOwnerMismatch';
  constructor() {
    super(
      'The authorization token account has a different owner than the update authority for the master edition!',
    );
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AuthorizationTokenAccountOwnerMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x22, () => new AuthorizationTokenAccountOwnerMismatchError());
createErrorFromNameLookup.set(
  'AuthorizationTokenAccountOwnerMismatch',
  () => new AuthorizationTokenAccountOwnerMismatchError(),
);

/**
 * Disabled: 'This feature is currently disabled.'
 *
 * @category Errors
 * @category generated
 */
export class DisabledError extends Error {
  readonly code: number = 0x23;
  readonly name: string = 'Disabled';
  constructor() {
    super('This feature is currently disabled.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DisabledError);
    }
  }
}

createErrorFromCodeLookup.set(0x23, () => new DisabledError());
createErrorFromNameLookup.set('Disabled', () => new DisabledError());

/**
 * CreatorsTooLong: 'Creators list too long'
 *
 * @category Errors
 * @category generated
 */
export class CreatorsTooLongError extends Error {
  readonly code: number = 0x24;
  readonly name: string = 'CreatorsTooLong';
  constructor() {
    super('Creators list too long');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CreatorsTooLongError);
    }
  }
}

createErrorFromCodeLookup.set(0x24, () => new CreatorsTooLongError());
createErrorFromNameLookup.set('CreatorsTooLong', () => new CreatorsTooLongError());

/**
 * CreatorsMustBeAtleastOne: 'Creators must be at least one if set'
 *
 * @category Errors
 * @category generated
 */
export class CreatorsMustBeAtleastOneError extends Error {
  readonly code: number = 0x25;
  readonly name: string = 'CreatorsMustBeAtleastOne';
  constructor() {
    super('Creators must be at least one if set');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CreatorsMustBeAtleastOneError);
    }
  }
}

createErrorFromCodeLookup.set(0x25, () => new CreatorsMustBeAtleastOneError());
createErrorFromNameLookup.set(
  'CreatorsMustBeAtleastOne',
  () => new CreatorsMustBeAtleastOneError(),
);

/**
 * MustBeOneOfCreators: 'If using a creators array, you must be one of the creators listed'
 *
 * @category Errors
 * @category generated
 */
export class MustBeOneOfCreatorsError extends Error {
  readonly code: number = 0x26;
  readonly name: string = 'MustBeOneOfCreators';
  constructor() {
    super('If using a creators array, you must be one of the creators listed');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MustBeOneOfCreatorsError);
    }
  }
}

createErrorFromCodeLookup.set(0x26, () => new MustBeOneOfCreatorsError());
createErrorFromNameLookup.set('MustBeOneOfCreators', () => new MustBeOneOfCreatorsError());

/**
 * NoCreatorsPresentOnMetadata: 'This metadata does not have creators'
 *
 * @category Errors
 * @category generated
 */
export class NoCreatorsPresentOnMetadataError extends Error {
  readonly code: number = 0x27;
  readonly name: string = 'NoCreatorsPresentOnMetadata';
  constructor() {
    super('This metadata does not have creators');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoCreatorsPresentOnMetadataError);
    }
  }
}

createErrorFromCodeLookup.set(0x27, () => new NoCreatorsPresentOnMetadataError());
createErrorFromNameLookup.set(
  'NoCreatorsPresentOnMetadata',
  () => new NoCreatorsPresentOnMetadataError(),
);

/**
 * CreatorNotFound: 'This creator address was not found'
 *
 * @category Errors
 * @category generated
 */
export class CreatorNotFoundError extends Error {
  readonly code: number = 0x28;
  readonly name: string = 'CreatorNotFound';
  constructor() {
    super('This creator address was not found');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CreatorNotFoundError);
    }
  }
}

createErrorFromCodeLookup.set(0x28, () => new CreatorNotFoundError());
createErrorFromNameLookup.set('CreatorNotFound', () => new CreatorNotFoundError());

/**
 * InvalidBasisPoints: 'Basis points cannot be more than 10000'
 *
 * @category Errors
 * @category generated
 */
export class InvalidBasisPointsError extends Error {
  readonly code: number = 0x29;
  readonly name: string = 'InvalidBasisPoints';
  constructor() {
    super('Basis points cannot be more than 10000');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidBasisPointsError);
    }
  }
}

createErrorFromCodeLookup.set(0x29, () => new InvalidBasisPointsError());
createErrorFromNameLookup.set('InvalidBasisPoints', () => new InvalidBasisPointsError());

/**
 * PrimarySaleCanOnlyBeFlippedToTrue: 'Primary sale can only be flipped to true and is immutable'
 *
 * @category Errors
 * @category generated
 */
export class PrimarySaleCanOnlyBeFlippedToTrueError extends Error {
  readonly code: number = 0x2a;
  readonly name: string = 'PrimarySaleCanOnlyBeFlippedToTrue';
  constructor() {
    super('Primary sale can only be flipped to true and is immutable');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PrimarySaleCanOnlyBeFlippedToTrueError);
    }
  }
}

createErrorFromCodeLookup.set(0x2a, () => new PrimarySaleCanOnlyBeFlippedToTrueError());
createErrorFromNameLookup.set(
  'PrimarySaleCanOnlyBeFlippedToTrue',
  () => new PrimarySaleCanOnlyBeFlippedToTrueError(),
);

/**
 * OwnerMismatch: 'Owner does not match that on the account given'
 *
 * @category Errors
 * @category generated
 */
export class OwnerMismatchError extends Error {
  readonly code: number = 0x2b;
  readonly name: string = 'OwnerMismatch';
  constructor() {
    super('Owner does not match that on the account given');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, OwnerMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x2b, () => new OwnerMismatchError());
createErrorFromNameLookup.set('OwnerMismatch', () => new OwnerMismatchError());

/**
 * NoBalanceInAccountForAuthorization: 'This account has no tokens to be used for authorization'
 *
 * @category Errors
 * @category generated
 */
export class NoBalanceInAccountForAuthorizationError extends Error {
  readonly code: number = 0x2c;
  readonly name: string = 'NoBalanceInAccountForAuthorization';
  constructor() {
    super('This account has no tokens to be used for authorization');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoBalanceInAccountForAuthorizationError);
    }
  }
}

createErrorFromCodeLookup.set(0x2c, () => new NoBalanceInAccountForAuthorizationError());
createErrorFromNameLookup.set(
  'NoBalanceInAccountForAuthorization',
  () => new NoBalanceInAccountForAuthorizationError(),
);

/**
 * ShareTotalMustBe100: 'Share total must equal 100 for creator array'
 *
 * @category Errors
 * @category generated
 */
export class ShareTotalMustBe100Error extends Error {
  readonly code: number = 0x2d;
  readonly name: string = 'ShareTotalMustBe100';
  constructor() {
    super('Share total must equal 100 for creator array');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ShareTotalMustBe100Error);
    }
  }
}

createErrorFromCodeLookup.set(0x2d, () => new ShareTotalMustBe100Error());
createErrorFromNameLookup.set('ShareTotalMustBe100', () => new ShareTotalMustBe100Error());

/**
 * ReservationExists: 'This reservation list already exists!'
 *
 * @category Errors
 * @category generated
 */
export class ReservationExistsError extends Error {
  readonly code: number = 0x2e;
  readonly name: string = 'ReservationExists';
  constructor() {
    super('This reservation list already exists!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ReservationExistsError);
    }
  }
}

createErrorFromCodeLookup.set(0x2e, () => new ReservationExistsError());
createErrorFromNameLookup.set('ReservationExists', () => new ReservationExistsError());

/**
 * ReservationDoesNotExist: 'This reservation list does not exist!'
 *
 * @category Errors
 * @category generated
 */
export class ReservationDoesNotExistError extends Error {
  readonly code: number = 0x2f;
  readonly name: string = 'ReservationDoesNotExist';
  constructor() {
    super('This reservation list does not exist!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ReservationDoesNotExistError);
    }
  }
}

createErrorFromCodeLookup.set(0x2f, () => new ReservationDoesNotExistError());
createErrorFromNameLookup.set('ReservationDoesNotExist', () => new ReservationDoesNotExistError());

/**
 * ReservationNotSet: 'This reservation list exists but was never set with reservations'
 *
 * @category Errors
 * @category generated
 */
export class ReservationNotSetError extends Error {
  readonly code: number = 0x30;
  readonly name: string = 'ReservationNotSet';
  constructor() {
    super('This reservation list exists but was never set with reservations');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ReservationNotSetError);
    }
  }
}

createErrorFromCodeLookup.set(0x30, () => new ReservationNotSetError());
createErrorFromNameLookup.set('ReservationNotSet', () => new ReservationNotSetError());

/**
 * ReservationAlreadyMade: 'This reservation list has already been set!'
 *
 * @category Errors
 * @category generated
 */
export class ReservationAlreadyMadeError extends Error {
  readonly code: number = 0x31;
  readonly name: string = 'ReservationAlreadyMade';
  constructor() {
    super('This reservation list has already been set!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ReservationAlreadyMadeError);
    }
  }
}

createErrorFromCodeLookup.set(0x31, () => new ReservationAlreadyMadeError());
createErrorFromNameLookup.set('ReservationAlreadyMade', () => new ReservationAlreadyMadeError());

/**
 * BeyondMaxAddressSize: 'Provided more addresses than max allowed in single reservation'
 *
 * @category Errors
 * @category generated
 */
export class BeyondMaxAddressSizeError extends Error {
  readonly code: number = 0x32;
  readonly name: string = 'BeyondMaxAddressSize';
  constructor() {
    super('Provided more addresses than max allowed in single reservation');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, BeyondMaxAddressSizeError);
    }
  }
}

createErrorFromCodeLookup.set(0x32, () => new BeyondMaxAddressSizeError());
createErrorFromNameLookup.set('BeyondMaxAddressSize', () => new BeyondMaxAddressSizeError());

/**
 * NumericalOverflowError: 'NumericalOverflowError'
 *
 * @category Errors
 * @category generated
 */
export class NumericalOverflowErrorError extends Error {
  readonly code: number = 0x33;
  readonly name: string = 'NumericalOverflowError';
  constructor() {
    super('NumericalOverflowError');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NumericalOverflowErrorError);
    }
  }
}

createErrorFromCodeLookup.set(0x33, () => new NumericalOverflowErrorError());
createErrorFromNameLookup.set('NumericalOverflowError', () => new NumericalOverflowErrorError());

/**
 * ReservationBreachesMaximumSupply: 'This reservation would go beyond the maximum supply of the master edition!'
 *
 * @category Errors
 * @category generated
 */
export class ReservationBreachesMaximumSupplyError extends Error {
  readonly code: number = 0x34;
  readonly name: string = 'ReservationBreachesMaximumSupply';
  constructor() {
    super('This reservation would go beyond the maximum supply of the master edition!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ReservationBreachesMaximumSupplyError);
    }
  }
}

createErrorFromCodeLookup.set(0x34, () => new ReservationBreachesMaximumSupplyError());
createErrorFromNameLookup.set(
  'ReservationBreachesMaximumSupply',
  () => new ReservationBreachesMaximumSupplyError(),
);

/**
 * AddressNotInReservation: 'Address not in reservation!'
 *
 * @category Errors
 * @category generated
 */
export class AddressNotInReservationError extends Error {
  readonly code: number = 0x35;
  readonly name: string = 'AddressNotInReservation';
  constructor() {
    super('Address not in reservation!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AddressNotInReservationError);
    }
  }
}

createErrorFromCodeLookup.set(0x35, () => new AddressNotInReservationError());
createErrorFromNameLookup.set('AddressNotInReservation', () => new AddressNotInReservationError());

/**
 * CannotVerifyAnotherCreator: 'You cannot unilaterally verify another creator, they must sign'
 *
 * @category Errors
 * @category generated
 */
export class CannotVerifyAnotherCreatorError extends Error {
  readonly code: number = 0x36;
  readonly name: string = 'CannotVerifyAnotherCreator';
  constructor() {
    super('You cannot unilaterally verify another creator, they must sign');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CannotVerifyAnotherCreatorError);
    }
  }
}

createErrorFromCodeLookup.set(0x36, () => new CannotVerifyAnotherCreatorError());
createErrorFromNameLookup.set(
  'CannotVerifyAnotherCreator',
  () => new CannotVerifyAnotherCreatorError(),
);

/**
 * CannotUnverifyAnotherCreator: 'You cannot unilaterally unverify another creator'
 *
 * @category Errors
 * @category generated
 */
export class CannotUnverifyAnotherCreatorError extends Error {
  readonly code: number = 0x37;
  readonly name: string = 'CannotUnverifyAnotherCreator';
  constructor() {
    super('You cannot unilaterally unverify another creator');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CannotUnverifyAnotherCreatorError);
    }
  }
}

createErrorFromCodeLookup.set(0x37, () => new CannotUnverifyAnotherCreatorError());
createErrorFromNameLookup.set(
  'CannotUnverifyAnotherCreator',
  () => new CannotUnverifyAnotherCreatorError(),
);

/**
 * SpotMismatch: 'In initial reservation setting, spots remaining should equal total spots'
 *
 * @category Errors
 * @category generated
 */
export class SpotMismatchError extends Error {
  readonly code: number = 0x38;
  readonly name: string = 'SpotMismatch';
  constructor() {
    super('In initial reservation setting, spots remaining should equal total spots');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, SpotMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x38, () => new SpotMismatchError());
createErrorFromNameLookup.set('SpotMismatch', () => new SpotMismatchError());

/**
 * IncorrectOwner: 'Incorrect account owner'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectOwnerError extends Error {
  readonly code: number = 0x39;
  readonly name: string = 'IncorrectOwner';
  constructor() {
    super('Incorrect account owner');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IncorrectOwnerError);
    }
  }
}

createErrorFromCodeLookup.set(0x39, () => new IncorrectOwnerError());
createErrorFromNameLookup.set('IncorrectOwner', () => new IncorrectOwnerError());

/**
 * PrintingWouldBreachMaximumSupply: 'printing these tokens would breach the maximum supply limit of the master edition'
 *
 * @category Errors
 * @category generated
 */
export class PrintingWouldBreachMaximumSupplyError extends Error {
  readonly code: number = 0x3a;
  readonly name: string = 'PrintingWouldBreachMaximumSupply';
  constructor() {
    super('printing these tokens would breach the maximum supply limit of the master edition');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PrintingWouldBreachMaximumSupplyError);
    }
  }
}

createErrorFromCodeLookup.set(0x3a, () => new PrintingWouldBreachMaximumSupplyError());
createErrorFromNameLookup.set(
  'PrintingWouldBreachMaximumSupply',
  () => new PrintingWouldBreachMaximumSupplyError(),
);

/**
 * DataIsImmutable: 'Data is immutable'
 *
 * @category Errors
 * @category generated
 */
export class DataIsImmutableError extends Error {
  readonly code: number = 0x3b;
  readonly name: string = 'DataIsImmutable';
  constructor() {
    super('Data is immutable');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DataIsImmutableError);
    }
  }
}

createErrorFromCodeLookup.set(0x3b, () => new DataIsImmutableError());
createErrorFromNameLookup.set('DataIsImmutable', () => new DataIsImmutableError());

/**
 * DuplicateCreatorAddress: 'No duplicate creator addresses'
 *
 * @category Errors
 * @category generated
 */
export class DuplicateCreatorAddressError extends Error {
  readonly code: number = 0x3c;
  readonly name: string = 'DuplicateCreatorAddress';
  constructor() {
    super('No duplicate creator addresses');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DuplicateCreatorAddressError);
    }
  }
}

createErrorFromCodeLookup.set(0x3c, () => new DuplicateCreatorAddressError());
createErrorFromNameLookup.set('DuplicateCreatorAddress', () => new DuplicateCreatorAddressError());

/**
 * ReservationSpotsRemainingShouldMatchTotalSpotsAtStart: 'Reservation spots remaining should match total spots when first being created'
 *
 * @category Errors
 * @category generated
 */
export class ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError extends Error {
  readonly code: number = 0x3d;
  readonly name: string = 'ReservationSpotsRemainingShouldMatchTotalSpotsAtStart';
  constructor() {
    super('Reservation spots remaining should match total spots when first being created');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x3d,
  () => new ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError(),
);
createErrorFromNameLookup.set(
  'ReservationSpotsRemainingShouldMatchTotalSpotsAtStart',
  () => new ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError(),
);

/**
 * InvalidTokenProgram: 'Invalid token program'
 *
 * @category Errors
 * @category generated
 */
export class InvalidTokenProgramError extends Error {
  readonly code: number = 0x3e;
  readonly name: string = 'InvalidTokenProgram';
  constructor() {
    super('Invalid token program');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidTokenProgramError);
    }
  }
}

createErrorFromCodeLookup.set(0x3e, () => new InvalidTokenProgramError());
createErrorFromNameLookup.set('InvalidTokenProgram', () => new InvalidTokenProgramError());

/**
 * DataTypeMismatch: 'Data type mismatch'
 *
 * @category Errors
 * @category generated
 */
export class DataTypeMismatchError extends Error {
  readonly code: number = 0x3f;
  readonly name: string = 'DataTypeMismatch';
  constructor() {
    super('Data type mismatch');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DataTypeMismatchError);
    }
  }
}

createErrorFromCodeLookup.set(0x3f, () => new DataTypeMismatchError());
createErrorFromNameLookup.set('DataTypeMismatch', () => new DataTypeMismatchError());

/**
 * BeyondAlottedAddressSize: 'Beyond alotted address size in reservation!'
 *
 * @category Errors
 * @category generated
 */
export class BeyondAlottedAddressSizeError extends Error {
  readonly code: number = 0x40;
  readonly name: string = 'BeyondAlottedAddressSize';
  constructor() {
    super('Beyond alotted address size in reservation!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, BeyondAlottedAddressSizeError);
    }
  }
}

createErrorFromCodeLookup.set(0x40, () => new BeyondAlottedAddressSizeError());
createErrorFromNameLookup.set(
  'BeyondAlottedAddressSize',
  () => new BeyondAlottedAddressSizeError(),
);

/**
 * ReservationNotComplete: 'The reservation has only been partially alotted'
 *
 * @category Errors
 * @category generated
 */
export class ReservationNotCompleteError extends Error {
  readonly code: number = 0x41;
  readonly name: string = 'ReservationNotComplete';
  constructor() {
    super('The reservation has only been partially alotted');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ReservationNotCompleteError);
    }
  }
}

createErrorFromCodeLookup.set(0x41, () => new ReservationNotCompleteError());
createErrorFromNameLookup.set('ReservationNotComplete', () => new ReservationNotCompleteError());

/**
 * TriedToReplaceAnExistingReservation: 'You cannot splice over an existing reservation!'
 *
 * @category Errors
 * @category generated
 */
export class TriedToReplaceAnExistingReservationError extends Error {
  readonly code: number = 0x42;
  readonly name: string = 'TriedToReplaceAnExistingReservation';
  constructor() {
    super('You cannot splice over an existing reservation!');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TriedToReplaceAnExistingReservationError);
    }
  }
}

createErrorFromCodeLookup.set(0x42, () => new TriedToReplaceAnExistingReservationError());
createErrorFromNameLookup.set(
  'TriedToReplaceAnExistingReservation',
  () => new TriedToReplaceAnExistingReservationError(),
);

/**
 * InvalidOperation: 'Invalid operation'
 *
 * @category Errors
 * @category generated
 */
export class InvalidOperationError extends Error {
  readonly code: number = 0x43;
  readonly name: string = 'InvalidOperation';
  constructor() {
    super('Invalid operation');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidOperationError);
    }
  }
}

createErrorFromCodeLookup.set(0x43, () => new InvalidOperationError());
createErrorFromNameLookup.set('InvalidOperation', () => new InvalidOperationError());

/**
 * InvalidOwner: 'Invalid Owner'
 *
 * @category Errors
 * @category generated
 */
export class InvalidOwnerError extends Error {
  readonly code: number = 0x44;
  readonly name: string = 'InvalidOwner';
  constructor() {
    super('Invalid Owner');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidOwnerError);
    }
  }
}

createErrorFromCodeLookup.set(0x44, () => new InvalidOwnerError());
createErrorFromNameLookup.set('InvalidOwner', () => new InvalidOwnerError());

/**
 * PrintingMintSupplyMustBeZeroForConversion: 'Printing mint supply must be zero for conversion'
 *
 * @category Errors
 * @category generated
 */
export class PrintingMintSupplyMustBeZeroForConversionError extends Error {
  readonly code: number = 0x45;
  readonly name: string = 'PrintingMintSupplyMustBeZeroForConversion';
  constructor() {
    super('Printing mint supply must be zero for conversion');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, PrintingMintSupplyMustBeZeroForConversionError);
    }
  }
}

createErrorFromCodeLookup.set(0x45, () => new PrintingMintSupplyMustBeZeroForConversionError());
createErrorFromNameLookup.set(
  'PrintingMintSupplyMustBeZeroForConversion',
  () => new PrintingMintSupplyMustBeZeroForConversionError(),
);

/**
 * OneTimeAuthMintSupplyMustBeZeroForConversion: 'One Time Auth mint supply must be zero for conversion'
 *
 * @category Errors
 * @category generated
 */
export class OneTimeAuthMintSupplyMustBeZeroForConversionError extends Error {
  readonly code: number = 0x46;
  readonly name: string = 'OneTimeAuthMintSupplyMustBeZeroForConversion';
  constructor() {
    super('One Time Auth mint supply must be zero for conversion');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, OneTimeAuthMintSupplyMustBeZeroForConversionError);
    }
  }
}

createErrorFromCodeLookup.set(0x46, () => new OneTimeAuthMintSupplyMustBeZeroForConversionError());
createErrorFromNameLookup.set(
  'OneTimeAuthMintSupplyMustBeZeroForConversion',
  () => new OneTimeAuthMintSupplyMustBeZeroForConversionError(),
);

/**
 * InvalidEditionIndex: 'You tried to insert one edition too many into an edition mark pda'
 *
 * @category Errors
 * @category generated
 */
export class InvalidEditionIndexError extends Error {
  readonly code: number = 0x47;
  readonly name: string = 'InvalidEditionIndex';
  constructor() {
    super('You tried to insert one edition too many into an edition mark pda');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidEditionIndexError);
    }
  }
}

createErrorFromCodeLookup.set(0x47, () => new InvalidEditionIndexError());
createErrorFromNameLookup.set('InvalidEditionIndex', () => new InvalidEditionIndexError());

/**
 * ReservationArrayShouldBeSizeOne: 'In the legacy system the reservation needs to be of size one for cpu limit reasons'
 *
 * @category Errors
 * @category generated
 */
export class ReservationArrayShouldBeSizeOneError extends Error {
  readonly code: number = 0x48;
  readonly name: string = 'ReservationArrayShouldBeSizeOne';
  constructor() {
    super('In the legacy system the reservation needs to be of size one for cpu limit reasons');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ReservationArrayShouldBeSizeOneError);
    }
  }
}

createErrorFromCodeLookup.set(0x48, () => new ReservationArrayShouldBeSizeOneError());
createErrorFromNameLookup.set(
  'ReservationArrayShouldBeSizeOne',
  () => new ReservationArrayShouldBeSizeOneError(),
);

/**
 * IsMutableCanOnlyBeFlippedToFalse: 'Is Mutable can only be flipped to false'
 *
 * @category Errors
 * @category generated
 */
export class IsMutableCanOnlyBeFlippedToFalseError extends Error {
  readonly code: number = 0x49;
  readonly name: string = 'IsMutableCanOnlyBeFlippedToFalse';
  constructor() {
    super('Is Mutable can only be flipped to false');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, IsMutableCanOnlyBeFlippedToFalseError);
    }
  }
}

createErrorFromCodeLookup.set(0x49, () => new IsMutableCanOnlyBeFlippedToFalseError());
createErrorFromNameLookup.set(
  'IsMutableCanOnlyBeFlippedToFalse',
  () => new IsMutableCanOnlyBeFlippedToFalseError(),
);

/**
 * CollectionCannotBeVerifiedInThisInstruction: 'Cannont Verify Collection in this Instruction'
 *
 * @category Errors
 * @category generated
 */
export class CollectionCannotBeVerifiedInThisInstructionError extends Error {
  readonly code: number = 0x4a;
  readonly name: string = 'CollectionCannotBeVerifiedInThisInstruction';
  constructor() {
    super('Cannont Verify Collection in this Instruction');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CollectionCannotBeVerifiedInThisInstructionError);
    }
  }
}

createErrorFromCodeLookup.set(0x4a, () => new CollectionCannotBeVerifiedInThisInstructionError());
createErrorFromNameLookup.set(
  'CollectionCannotBeVerifiedInThisInstruction',
  () => new CollectionCannotBeVerifiedInThisInstructionError(),
);

/**
 * Removed: 'This instruction was deprecated in a previous release and is now removed'
 *
 * @category Errors
 * @category generated
 */
export class RemovedError extends Error {
  readonly code: number = 0x4b;
  readonly name: string = 'Removed';
  constructor() {
    super('This instruction was deprecated in a previous release and is now removed');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, RemovedError);
    }
  }
}

createErrorFromCodeLookup.set(0x4b, () => new RemovedError());
createErrorFromNameLookup.set('Removed', () => new RemovedError());

/**
 * MustBeBurned: 'This token use method is burn and there are no remaining uses, it must be burned'
 *
 * @category Errors
 * @category generated
 */
export class MustBeBurnedError extends Error {
  readonly code: number = 0x4c;
  readonly name: string = 'MustBeBurned';
  constructor() {
    super('This token use method is burn and there are no remaining uses, it must be burned');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MustBeBurnedError);
    }
  }
}

createErrorFromCodeLookup.set(0x4c, () => new MustBeBurnedError());
createErrorFromNameLookup.set('MustBeBurned', () => new MustBeBurnedError());

/**
 * InvalidUseMethod: 'This use method is invalid'
 *
 * @category Errors
 * @category generated
 */
export class InvalidUseMethodError extends Error {
  readonly code: number = 0x4d;
  readonly name: string = 'InvalidUseMethod';
  constructor() {
    super('This use method is invalid');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidUseMethodError);
    }
  }
}

createErrorFromCodeLookup.set(0x4d, () => new InvalidUseMethodError());
createErrorFromNameLookup.set('InvalidUseMethod', () => new InvalidUseMethodError());

/**
 * CannotChangeUseMethodAfterFirstUse: 'Cannot Change Use Method after the first use'
 *
 * @category Errors
 * @category generated
 */
export class CannotChangeUseMethodAfterFirstUseError extends Error {
  readonly code: number = 0x4e;
  readonly name: string = 'CannotChangeUseMethodAfterFirstUse';
  constructor() {
    super('Cannot Change Use Method after the first use');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CannotChangeUseMethodAfterFirstUseError);
    }
  }
}

createErrorFromCodeLookup.set(0x4e, () => new CannotChangeUseMethodAfterFirstUseError());
createErrorFromNameLookup.set(
  'CannotChangeUseMethodAfterFirstUse',
  () => new CannotChangeUseMethodAfterFirstUseError(),
);

/**
 * CannotChangeUsesAfterFirstUse: 'Cannot Change Remaining or Available uses after the first use'
 *
 * @category Errors
 * @category generated
 */
export class CannotChangeUsesAfterFirstUseError extends Error {
  readonly code: number = 0x4f;
  readonly name: string = 'CannotChangeUsesAfterFirstUse';
  constructor() {
    super('Cannot Change Remaining or Available uses after the first use');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CannotChangeUsesAfterFirstUseError);
    }
  }
}

createErrorFromCodeLookup.set(0x4f, () => new CannotChangeUsesAfterFirstUseError());
createErrorFromNameLookup.set(
  'CannotChangeUsesAfterFirstUse',
  () => new CannotChangeUsesAfterFirstUseError(),
);

/**
 * CollectionNotFound: 'Collection Not Found on Metadata'
 *
 * @category Errors
 * @category generated
 */
export class CollectionNotFoundError extends Error {
  readonly code: number = 0x50;
  readonly name: string = 'CollectionNotFound';
  constructor() {
    super('Collection Not Found on Metadata');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CollectionNotFoundError);
    }
  }
}

createErrorFromCodeLookup.set(0x50, () => new CollectionNotFoundError());
createErrorFromNameLookup.set('CollectionNotFound', () => new CollectionNotFoundError());

/**
 * InvalidCollectionUpdateAuthority: 'Collection Update Authority is invalid'
 *
 * @category Errors
 * @category generated
 */
export class InvalidCollectionUpdateAuthorityError extends Error {
  readonly code: number = 0x51;
  readonly name: string = 'InvalidCollectionUpdateAuthority';
  constructor() {
    super('Collection Update Authority is invalid');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidCollectionUpdateAuthorityError);
    }
  }
}

createErrorFromCodeLookup.set(0x51, () => new InvalidCollectionUpdateAuthorityError());
createErrorFromNameLookup.set(
  'InvalidCollectionUpdateAuthority',
  () => new InvalidCollectionUpdateAuthorityError(),
);

/**
 * CollectionMustBeAUniqueMasterEdition: 'Collection Must Be a Unique Master Edition v2'
 *
 * @category Errors
 * @category generated
 */
export class CollectionMustBeAUniqueMasterEditionError extends Error {
  readonly code: number = 0x52;
  readonly name: string = 'CollectionMustBeAUniqueMasterEdition';
  constructor() {
    super('Collection Must Be a Unique Master Edition v2');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CollectionMustBeAUniqueMasterEditionError);
    }
  }
}

createErrorFromCodeLookup.set(0x52, () => new CollectionMustBeAUniqueMasterEditionError());
createErrorFromNameLookup.set(
  'CollectionMustBeAUniqueMasterEdition',
  () => new CollectionMustBeAUniqueMasterEditionError(),
);

/**
 * UseAuthorityRecordAlreadyExists: 'The Use Authority Record Already Exists, to modify it Revoke, then Approve'
 *
 * @category Errors
 * @category generated
 */
export class UseAuthorityRecordAlreadyExistsError extends Error {
  readonly code: number = 0x53;
  readonly name: string = 'UseAuthorityRecordAlreadyExists';
  constructor() {
    super('The Use Authority Record Already Exists, to modify it Revoke, then Approve');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UseAuthorityRecordAlreadyExistsError);
    }
  }
}

createErrorFromCodeLookup.set(0x53, () => new UseAuthorityRecordAlreadyExistsError());
createErrorFromNameLookup.set(
  'UseAuthorityRecordAlreadyExists',
  () => new UseAuthorityRecordAlreadyExistsError(),
);

/**
 * UseAuthorityRecordAlreadyRevoked: 'The Use Authority Record is empty or already revoked'
 *
 * @category Errors
 * @category generated
 */
export class UseAuthorityRecordAlreadyRevokedError extends Error {
  readonly code: number = 0x54;
  readonly name: string = 'UseAuthorityRecordAlreadyRevoked';
  constructor() {
    super('The Use Authority Record is empty or already revoked');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UseAuthorityRecordAlreadyRevokedError);
    }
  }
}

createErrorFromCodeLookup.set(0x54, () => new UseAuthorityRecordAlreadyRevokedError());
createErrorFromNameLookup.set(
  'UseAuthorityRecordAlreadyRevoked',
  () => new UseAuthorityRecordAlreadyRevokedError(),
);

/**
 * Unusable: 'This token has no uses'
 *
 * @category Errors
 * @category generated
 */
export class UnusableError extends Error {
  readonly code: number = 0x55;
  readonly name: string = 'Unusable';
  constructor() {
    super('This token has no uses');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, UnusableError);
    }
  }
}

createErrorFromCodeLookup.set(0x55, () => new UnusableError());
createErrorFromNameLookup.set('Unusable', () => new UnusableError());

/**
 * NotEnoughUses: 'There are not enough Uses left on this token.'
 *
 * @category Errors
 * @category generated
 */
export class NotEnoughUsesError extends Error {
  readonly code: number = 0x56;
  readonly name: string = 'NotEnoughUses';
  constructor() {
    super('There are not enough Uses left on this token.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotEnoughUsesError);
    }
  }
}

createErrorFromCodeLookup.set(0x56, () => new NotEnoughUsesError());
createErrorFromNameLookup.set('NotEnoughUses', () => new NotEnoughUsesError());

/**
 * CollectionAuthorityRecordAlreadyExists: 'This Collection Authority Record Already Exists.'
 *
 * @category Errors
 * @category generated
 */
export class CollectionAuthorityRecordAlreadyExistsError extends Error {
  readonly code: number = 0x57;
  readonly name: string = 'CollectionAuthorityRecordAlreadyExists';
  constructor() {
    super('This Collection Authority Record Already Exists.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CollectionAuthorityRecordAlreadyExistsError);
    }
  }
}

createErrorFromCodeLookup.set(0x57, () => new CollectionAuthorityRecordAlreadyExistsError());
createErrorFromNameLookup.set(
  'CollectionAuthorityRecordAlreadyExists',
  () => new CollectionAuthorityRecordAlreadyExistsError(),
);

/**
 * CollectionAuthorityDoesNotExist: 'This Collection Authority Record Does Not Exist.'
 *
 * @category Errors
 * @category generated
 */
export class CollectionAuthorityDoesNotExistError extends Error {
  readonly code: number = 0x58;
  readonly name: string = 'CollectionAuthorityDoesNotExist';
  constructor() {
    super('This Collection Authority Record Does Not Exist.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CollectionAuthorityDoesNotExistError);
    }
  }
}

createErrorFromCodeLookup.set(0x58, () => new CollectionAuthorityDoesNotExistError());
createErrorFromNameLookup.set(
  'CollectionAuthorityDoesNotExist',
  () => new CollectionAuthorityDoesNotExistError(),
);

/**
 * InvalidUseAuthorityRecord: 'This Use Authority Record is invalid.'
 *
 * @category Errors
 * @category generated
 */
export class InvalidUseAuthorityRecordError extends Error {
  readonly code: number = 0x59;
  readonly name: string = 'InvalidUseAuthorityRecord';
  constructor() {
    super('This Use Authority Record is invalid.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidUseAuthorityRecordError);
    }
  }
}

createErrorFromCodeLookup.set(0x59, () => new InvalidUseAuthorityRecordError());
createErrorFromNameLookup.set(
  'InvalidUseAuthorityRecord',
  () => new InvalidUseAuthorityRecordError(),
);

/**
 * InvalidCollectionAuthorityRecord: 'This Collection Authority Record is invalid.'
 *
 * @category Errors
 * @category generated
 */
export class InvalidCollectionAuthorityRecordError extends Error {
  readonly code: number = 0x5a;
  readonly name: string = 'InvalidCollectionAuthorityRecord';
  constructor() {
    super('This Collection Authority Record is invalid.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidCollectionAuthorityRecordError);
    }
  }
}

createErrorFromCodeLookup.set(0x5a, () => new InvalidCollectionAuthorityRecordError());
createErrorFromNameLookup.set(
  'InvalidCollectionAuthorityRecord',
  () => new InvalidCollectionAuthorityRecordError(),
);

/**
 * InvalidFreezeAuthority: 'Metadata does not match the freeze authority on the mint'
 *
 * @category Errors
 * @category generated
 */
export class InvalidFreezeAuthorityError extends Error {
  readonly code: number = 0x5b;
  readonly name: string = 'InvalidFreezeAuthority';
  constructor() {
    super('Metadata does not match the freeze authority on the mint');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidFreezeAuthorityError);
    }
  }
}

createErrorFromCodeLookup.set(0x5b, () => new InvalidFreezeAuthorityError());
createErrorFromNameLookup.set('InvalidFreezeAuthority', () => new InvalidFreezeAuthorityError());

/**
 * InvalidDelegate: 'All tokens in this account have not been delegated to this user.'
 *
 * @category Errors
 * @category generated
 */
export class InvalidDelegateError extends Error {
  readonly code: number = 0x5c;
  readonly name: string = 'InvalidDelegate';
  constructor() {
    super('All tokens in this account have not been delegated to this user.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidDelegateError);
    }
  }
}

createErrorFromCodeLookup.set(0x5c, () => new InvalidDelegateError());
createErrorFromNameLookup.set('InvalidDelegate', () => new InvalidDelegateError());

/**
 * CannotAdjustVerifiedCreator: 'Creator can not be adjusted once they are verified.'
 *
 * @category Errors
 * @category generated
 */
export class CannotAdjustVerifiedCreatorError extends Error {
  readonly code: number = 0x5d;
  readonly name: string = 'CannotAdjustVerifiedCreator';
  constructor() {
    super('Creator can not be adjusted once they are verified.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CannotAdjustVerifiedCreatorError);
    }
  }
}

createErrorFromCodeLookup.set(0x5d, () => new CannotAdjustVerifiedCreatorError());
createErrorFromNameLookup.set(
  'CannotAdjustVerifiedCreator',
  () => new CannotAdjustVerifiedCreatorError(),
);

/**
 * CannotRemoveVerifiedCreator: 'Verified creators cannot be removed.'
 *
 * @category Errors
 * @category generated
 */
export class CannotRemoveVerifiedCreatorError extends Error {
  readonly code: number = 0x5e;
  readonly name: string = 'CannotRemoveVerifiedCreator';
  constructor() {
    super('Verified creators cannot be removed.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CannotRemoveVerifiedCreatorError);
    }
  }
}

createErrorFromCodeLookup.set(0x5e, () => new CannotRemoveVerifiedCreatorError());
createErrorFromNameLookup.set(
  'CannotRemoveVerifiedCreator',
  () => new CannotRemoveVerifiedCreatorError(),
);

/**
 * CannotWipeVerifiedCreators: 'Can not wipe verified creators.'
 *
 * @category Errors
 * @category generated
 */
export class CannotWipeVerifiedCreatorsError extends Error {
  readonly code: number = 0x5f;
  readonly name: string = 'CannotWipeVerifiedCreators';
  constructor() {
    super('Can not wipe verified creators.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CannotWipeVerifiedCreatorsError);
    }
  }
}

createErrorFromCodeLookup.set(0x5f, () => new CannotWipeVerifiedCreatorsError());
createErrorFromNameLookup.set(
  'CannotWipeVerifiedCreators',
  () => new CannotWipeVerifiedCreatorsError(),
);

/**
 * NotAllowedToChangeSellerFeeBasisPoints: 'Not allowed to change seller fee basis points.'
 *
 * @category Errors
 * @category generated
 */
export class NotAllowedToChangeSellerFeeBasisPointsError extends Error {
  readonly code: number = 0x60;
  readonly name: string = 'NotAllowedToChangeSellerFeeBasisPoints';
  constructor() {
    super('Not allowed to change seller fee basis points.');
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotAllowedToChangeSellerFeeBasisPointsError);
    }
  }
}

createErrorFromCodeLookup.set(0x60, () => new NotAllowedToChangeSellerFeeBasisPointsError());
createErrorFromNameLookup.set(
  'NotAllowedToChangeSellerFeeBasisPoints',
  () => new NotAllowedToChangeSellerFeeBasisPointsError(),
);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
export function errorFromCode(code: number): MaybeErrorWithCode {
  const createError = createErrorFromCodeLookup.get(code);
  return createError != null ? createError() : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
export function errorFromName(name: string): MaybeErrorWithCode {
  const createError = createErrorFromNameLookup.get(name);
  return createError != null ? createError() : null;
}
